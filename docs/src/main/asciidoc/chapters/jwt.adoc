== Role based access control with JWT

Application security is one of the most important topics in the software development.
Provided you don't write a _Hello world_ app, you will definitely reach the point when you want to start controlling the access to some of your resources or functionalities.
But surprisingly how many different approaches there are for that at least in the Java space.
There are quite a few standards and at the same time most of the teams or companies breed their own solutions.

There are two core building blocks of the application security: authentication and authorization.
The first one's goal is to check whether the actor performing the action with the app is the one that they are pretending to be.
The most common approach to authentication is by providing user name and password in a login page.
But you can also authenticate with certificates (ever connected to AWS VM?).
Or using a third party identity provider like Google, Twitter, Github, Facebook, etc.
At the end, there is an agent that checks the provided credentials and confirms that the authenticating person is the one that they claim to be.

Once a user is authenticated, they can go on and start working with the site.
However, not all the resources and functionalities should be available to anyone.
Some of the pages or features may only be accessible by users in a certain role (e.g. admin or manager).
And user with lesser permissions should not be allowed to access them.

The existing Java EE specs (JAX-RS, Servlet, EJB, JAX-WS) have very strong authorization support.
Since Java EE 8 there is a new spec (Java EE Security) that also tackles the authentication topic very well.
However, in a microservice app we need to go a level up.
Not only both building blocks should work seamlessly together, but this should happen in an environment, where not every microservice can perform checks.

Imagine if upon each request, all the services in our app should validate the requesting user and their role(s).
This means that all of them should have access to the identity provider.
And that they should spend the time and resources for all the checks.
Even though that those time and resources were already spent a moment ago by another service.

There must be a better way.
And it is provided by MicroProfile's Resource-based access control (RBAC) with JSON Web Token (JWT) specification.
The spec defines a token format of token that is generated by presumably one microservice (or if you prefer gateway) upon receiving and accepting user credentials.
This token comes in the form of a Base64 encoded JSON object, holding information about the authenticated user (like first and last name, email, user groups, etc.).
After its generation, it is passed along every other request in its `Authorization` header.
Even if the request spans more than one microservice, each of them can decode the token and see the details of the user that sent it.
Without the need to authenticate it again.

The token is signed and its signature is checked by the MicroProfile implementations prior to calling the protected resources to avoid tempering with it.
The runtimes will also check if the token has expired (it usually expires in an hour).
In all such cases it will be the application server that will return response code 401 even before the request reaches the application code.
So in such cases the login gateway should be requested again to generate a new valid token.

In this chapter we will show you how the user service will generate such JWT string.
Then we will show you how the GUI service will use that in all the subsequent calls to other microservices and how it will decide whether a requester is authenticated or not.
After that we will see how microservice can define whether users are allowed to access certain resource or not.
Finally, we will find out the way that user information can be extracted from the JSON web token.

Let's start with the authentication.

=== User authentication

=== Role based access controll

=== JWT and user details
